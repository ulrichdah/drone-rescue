include "buzz_includes/buzz_utils/vec2.bzz"
include "config/search_example/parameters.bzz"
include "buzz_includes/search_example/utils.bzz"
include "buzz_includes/search_example/belief_search.bzz"
include "buzz_includes/debug.bzz"

var found_gps
var nb_step = 0
var waiting_log = 1

var current_bid_position = {}
var current_target = {}
var networkers_positions = {}
var initial_nb_networkers = -1

var graph = {}
var count_broadcast = 0
var count_broadcast_winner = 0
var cur_bid_id = 0
var current_best_bid = {.value = -1.0, .rid = -1}
var winners_acks = {}
var state_duration = 0


function init_stigmergies() {
  target_stigmergy = stigmergy.create(1)
  root_id_stigmergy = stigmergy.create(2)
  if ( id == 0 ) {
    target_stigmergy.put("found_targets", found_targets)
    root_id_stigmergy.put("root_id", -1)
  }
  target_stigmergy.onconflict(function(k, l, r){
    return l
  })
  target_stigmergy.onconflictlost(function(k, l){})

  map_stigmergy = stigmergy.create(3)
  map_stigmergy.onconflict(function(k, l, r){
    return l
  })
  map_stigmergy.onconflictlost(function(k, l){})
}

function init_listeners() {
  neighbors.listen(NETWORKERS_NEEDED_EVENT, function(vid, value, rid) {
    if (current_state == STATE_SEARCH or current_state == STATE_MEETING) {
      # get position for the bid
      current_bid_position = value.position
      cur_bid_id = value.id_bid
      current_state = STATE_NETWORKER_BIDDING
    }
  })
}

# Executed at init time
function init() {
  # Take off command for the Spiri drone model
  takeoff()

  # Show trajectory for debugging
  show_colored_trajectory(NUMBER_OF_ROBOTS)

  # Set first search position
  next_position.x = uniform(SEARCH_SPACE.minx, SEARCH_SPACE.maxx)
  next_position.y = uniform(SEARCH_SPACE.miny, SEARCH_SPACE.maxy)

  # Set initial state
  current_state = STATE_SEARCH
  found_gps = {.x = 0, .y = 0}
  
  init_stigmergies()
  init_listeners()
}

# Sample new position for search depending on the search algorithm
function search() {
  if (SEARCH_TYPE == 1) {
    random_belief_search()
  } else {
    random_search()
  }
}

# Check if a target is in sight
function has_discovered_target()
{ 
  return detect_targets()
}

# Returns difference between two vec2
function distance_v2(v1, v2) {
  return math.vec2.length(math.vec2.sub(v1, v2))   
}

# Check if given target position was already found
function is_new_target(target_position) {
  for (i = 0, i < size(found_targets), i = i + 1) {
    var existing_target_pos = found_targets[i].position
    var difference = distance_v2(existing_target_pos, target_position) 
    if (difference <= 5.0) {
      return 0
    }
  }
  return 1
}

# Check if a target was already processed (at least one existing relay)
function get_nearest_vertex(target_position) {
  var nearest_vertex = math.vec2.new(MEETING_POINT.x, MEETING_POINT.y) 
  var nearest_distance = distance_v2(nearest_vertex, target_position)
  for (i = 0, i < size(graph), i = i + 1) {
    if (distance_v2(graph[i], target_position) < nearest_distance) {
      nearest_vertex = graph[i]
      nearest_distance = distance_v2(graph[i], target_position)
    }
  }
  return nearest_vertex
}

# Returns a list of networkers positions for a given target
function get_networkers_positions(target_position) {
  var start = get_nearest_vertex(target_position)
  var distance = math.vec2.length(math.vec2.sub(target_position, start))
  var unit_direction = math.vec2.norm(math.vec2.sub(target_position, start))
  var nb_networkers = int(distance / COMMUNICATION_RANGE)
  if (distance % COMMUNICATION_RANGE != 0) {
    nb_networkers = nb_networkers + 1
  }
  log("Nb networker:", nb_networkers)
  var positions = {}
  for (i = 0, i < nb_networkers - 1, i = i + 1) {
    var new_pos = {.x = unit_direction.x * COMMUNICATION_RANGE * (i +1), .y = unit_direction.y * COMMUNICATION_RANGE * (i + 1)}
    positions[i] = math.vec2.add(start, new_pos)
    graph[size(graph)] = positions[i]
    log("Networker", i, ":", positions[i].x, ", ", positions[i].y)
  }
  positions[(nb_networkers - 1)] = target_position
  log("Networker", (nb_networkers - 1), ":", positions[(nb_networkers - 1)].x, ", ", positions[(nb_networkers - 1)].y)
  graph[size(graph)] = target_position
  return positions
}

# Returns a bid value based on the distance from the given position
function get_bid(position) {
  var distance = distance_v2(position, gps_position)
  return 1 / distance
}

function safe_stigmergy_get(v_stigmergy, key, default) {
  var tmp = v_stigmergy.get(key)
  if (tmp != nil) {
    return tmp
  } else {
    return default
  }
}

function search_state() {
  debug.print("Searching")
  # Look if a target is discovered
  if ( has_discovered_target() != 0 ) { 
    update_belief(0)
    found_gps.x = gps_position.x
    found_gps.y = gps_position.y
    current_state = STATE_FOUND
    current_search_step = 0      
  } 
  # If the max number of search step is reached go back to meeting point
  else if ( current_search_step >= NUMBER_OF_SEARCH_STEP ){ 
    next_position = math.vec2.new(MEETING_POINT.x, MEETING_POINT.y)
    goto(next_position.x, next_position.y)
    current_state = STATE_MEETING
    current_search_step = 0
    update_belief(0)
  }
  # Else continue searching
  else { 
    update_belief(0)
    if ( has_reached(next_position.x, next_position.y, DELTA_REACHED_POS) != 0 )
    {
      search()
      current_search_step = current_search_step + 1
    } else {
      goto(next_position.x, next_position.y)
    }
  }
}

function found_state() {
  debug.print("Found the target")

  # Wait for ack from root if exists before leaving this state
  neighbors.listen(NEW_TARGET_ACK_EVENT, function(vid, value, rid) {
    if (value == id) {
      neighbors.ignore(NEW_TARGET_ACK_EVENT)
      current_state = STATE_SEARCH
      search()
    }
  })

  if (is_new_target(found_gps) != 0) {
    log("[", id, "] New target")
    var root_id = safe_stigmergy_get(root_id_stigmergy, "root_id", -1)
    # Go to meeting zone if not there already
    if ( has_reached(MEETING_POINT.x, MEETING_POINT.y, DELTA_REACHED_POS) == 0) {
      goto(MEETING_POINT.x, MEETING_POINT.y)
      return
    }
    # We reached meeting zone
    if (root_id == -1) { # If no root exists, this drone is the root
      current_state =  STATE_ROOT
      root_id_stigmergy.put("root_id", id)
      found_targets[size(found_targets)] = {.processed = 0, .position = found_gps}
      target_stigmergy.put("found_targets", found_targets)
      return
    }
    neighbors.broadcast(NEW_TARGET_EVENT, found_gps)
  } else {
    current_state = STATE_SEARCH
    search()
  }
}

function root_state() {
  debug.print("ROOT")

  neighbors.ignore(NETWORKERS_NEEDED_EVENT)
  # Listen to broadcast for new_target
  neighbors.listen(NEW_TARGET_EVENT, function(vid, new_target_position, rid) {
    neighbors.broadcast(NEW_TARGET_ACK_EVENT, rid)
    var new_candidate = new_target_position
    if(is_new_target(new_candidate)) {
      # Add it to targets stack and update stigmergy
      found_targets[size(found_targets)] = {.processed = 0, .position = new_candidate}
      target_stigmergy.put("found_targets", found_targets)
    }
  })

  log("Number target = ", size(found_targets))

  var root_id = safe_stigmergy_get(root_id_stigmergy, "root_id", -1)
  if (root_id != id) {
    current_state =  STATE_SEARCH
    search()
    neighbors.ignore(NEW_TARGET_EVENT)
    neighbors.broadcast(NEW_TARGET_EVENT, found_gps)
    neighbors.ignore(BIDDING_VALUE_EVENT)
    init_listeners()
    return
  }

  # Process next target
  if (size(current_target) == 0) {
    log("NO CURRENT TARGET")
    var i = 0
    var continue = 1
    while(i < size(found_targets) and continue == 1) {
      if (found_targets[i].processed == 0) {
        current_target = found_targets[i].position
        found_targets[i].processed = 1
        continue = 0
      }
      i = i + 1
    }
  }

  # Create stack points for Networkers
  if (size(current_target) != 0) {
    log("CURRENT TARG: ", current_target.x, ", ", current_target.y)
    if (size(networkers_positions) == 0) {
      log("NO NETWORKERS LIST")
      networkers_positions = get_networkers_positions(current_target)
      initial_nb_networkers = size(networkers_positions)
    }

    # If unassigned position in stack
    if (size(current_bid_position) == 0) {
      var i = 0
      var continue = 1
      while(i < initial_nb_networkers and continue == 1) {
        if (networkers_positions[i] != nil) {
          current_bid_position = networkers_positions[i]
          current_best_bid = {.value = -1.0, .rid = -1}
          cur_bid_id = cur_bid_id + 1
          networkers_positions[i] = nil
          continue = 0
        }
        i = i + 1
      }
      # No more positions for this target
      if (size(networkers_positions) == 0) {
        log("Processed")
        current_target = {}
        initial_nb_networkers = -1
      }
    }
    if (size(current_bid_position) != 0) {
      current_state = STATE_AUCTIONEER 
    }
  }
}

function auctionner_state() {
  debug.print("Auctioneer")
  # Listen to networker bid
  neighbors.listen(BIDDING_VALUE_EVENT, function(vid, info_bid, rid) {
    # get bid value
    if (current_best_bid.value < info_bid.value and info_bid.id_bid == cur_bid_id) {
      current_best_bid.value = info_bid.value
      current_best_bid.rid = rid
    }
  })
  # Listen to winner acknowledgment
  neighbors.listen(WINNER_ACK_EVENT, function(vid, winner_id, rid) {
    if (current_best_bid.rid == winner_id) {
    log("[", id, "] Winner ACK", winner_id, "Cur_bid", current_best_bid.rid)
      winners_acks[cur_bid_id] = winner_id
      if (current_state == STATE_AUCTIONEER) {
        current_state = STATE_ROOT
        log("---- Back from auction ----")
        current_bid_position = {}
        count_broadcast_winner = 0
        count_broadcast = 0
        neighbors.ignore(WINNER_ACK_EVENT)
      }
    }
  })

  var root_id = safe_stigmergy_get(root_id_stigmergy, "root_id", -1)
  if (root_id != id) {
    current_state =  STATE_ROOT
    return
  }

  # Broadcast networker_needed with position
  if (count_broadcast < MAX_BROADCAST_STEP or current_best_bid.rid == -1) {
    neighbors.broadcast(NETWORKERS_NEEDED_EVENT, {.id_bid = cur_bid_id, .position = current_bid_position})
    count_broadcast = count_broadcast + 1
  } else { # Broadcast winner after a 10 steps
    neighbors.ignore(BIDDING_VALUE_EVENT)
    if (count_broadcast_winner < MAX_BROADCAST_STEP) {
      neighbors.broadcast(BID_WINNER_EVENT, current_best_bid.rid)
      log(" Winner is: ", current_best_bid.rid)
      count_broadcast_winner = count_broadcast_winner + 1
    } else {
      log("COntinue bidding")
      count_broadcast_winner = 0
      count_broadcast = 0
      current_best_bid = {.value = -1.0, .rid = -1}
    }
  }
}

function meeting_state() {
  debug.print("Periodic meeting")
  # Update local list of targets
  if ( has_reached(MEETING_POINT.x, MEETING_POINT.y, DELTA_REACHED_POS) == 0 ) {
    # Look for targets when comming back to meeting point
    if ( has_discovered_target() != 0 ) { 
      update_belief(0)
      found_gps.x = gps_position.x
      found_gps.y = gps_position.y
      current_state = STATE_FOUND
      current_search_step = 0      
    } else {
      update_belief(0)
    }
  }
  # When we get to the meeting point go back to searching when no networkers are needed
  else {
    found_target_info = { .found_by = -1, .x = 0.0, .y = 0.0 }
    next_position.x = uniform(SEARCH_SPACE.minx, SEARCH_SPACE.maxx)
    next_position.y = uniform(SEARCH_SPACE.miny, SEARCH_SPACE.maxy)
    goto(next_position.x, next_position.y)
    current_state = STATE_SEARCH
  }
}

function networker_bidding_state() {
  debug.print("Networker bidding")
  # Listen to winner 
  neighbors.listen(BID_WINNER_EVENT, function(vid, winner_id, rid) {
    if (winner_id == id) {
      state_duration = 0
      current_state = STATE_NETWORKER
      neighbors.ignore(NETWORKERS_NEEDED_EVENT)
    } else {
      current_state = STATE_SEARCH
      search()
      current_bid_position = {}
    }
    neighbors.ignore(BID_WINNER_EVENT)
  })
  if (has_reached(next_position.x, next_position.y, DELTA_REACHED_POS) == 0) {
    return
  }
  
  # For some reason, using MEETING_POINT instead of a magic value return ~0
  # if (distance_v2( {.x = 0.0, .y = -10.0}, gps_position) > COMMUNICATION_RANGE) {
  if (distance_v2(math.vec2.new(MEETING_POINT.x, MEETING_POINT.y) , gps_position) > COMMUNICATION_RANGE) {
    current_state = STATE_SEARCH
    search()
    return
  }
  if (state_duration < 20) {
    var r_bid = get_bid(current_bid_position)
    log("[", id, "] Bidding: ", cur_bid_id)
    neighbors.broadcast(BIDDING_VALUE_EVENT, {.id_bid = cur_bid_id, .value = r_bid})
    state_duration = state_duration + 1
  } else {
    state_duration = 0
    current_state = STATE_SEARCH
    search()
    current_bid_position = {}
  }
}

function networker_state() {
  debug.print("Networker", current_bid_position.x, current_bid_position.y)
  if (state_duration < 5) {
    neighbors.broadcast(WINNER_ACK_EVENT, id)
    state_duration = state_duration + 1
  } else {
    goto(current_bid_position.x, current_bid_position.y)
  }
}

# Executed every time step
function step() {
  update_gps_position()
  nb_step = nb_step + 1
  
  found_targets = safe_stigmergy_get(target_stigmergy, "found_targets", found_targets)
  
  if (current_state == STATE_SEARCH) { 
    search_state()
  } else if (current_state == STATE_FOUND) { 
    found_state()
  } else if (current_state == STATE_ROOT) {
    root_state()
  } else if (current_state == STATE_MEETING) { 
    meeting_state()
  } else if (current_state == STATE_NETWORKER_BIDDING) {
    networker_bidding_state()
  } else if (current_state == STATE_NETWORKER) {
    networker_state()
  } else if (current_state == STATE_AUCTIONEER) {
    auctionner_state()
  }
}
 
# Execute at exit
function destroy() {
}
