include "buzz_includes/buzz_utils/vec2.bzz"
include "config/search_example/parameters.bzz"
include "buzz_includes/search_example/utils.bzz"
include "buzz_includes/search_example/belief_search.bzz"
include "buzz_includes/debug.bzz"

var found_gps
var nb_step = 0
var waiting_log = 1

var position_bid 
var current_best = {.value = 0, .best_id = -1}


function init_stigmergies() {
  target_stigmergy = stigmergy.create(1)
  if ( id == 0 ) {
    target_stigmergy.put("found_target_info", found_target_info)
  }
  target_stigmergy.onconflict(function(k, l, r){
    return l
  })
  target_stigmergy.onconflictlost(function(k, l){})

  map_stigmergy = stigmergy.create(2)
  map_stigmergy.onconflict(function(k, l, r){
    return l
  })
  map_stigmergy.onconflictlost(function(k, l){})
}

function init_listeners() {
  neighbors.listen("networkers_need", function(vid, value, rid) {
    if (current_state == STATE_SEARCH or current_state == STATE_MEETING) {
      # get position for the bid
      position_bid = value
      log("POSTION FOR BID", position_bid)
      current_state = STATE_NETWORKER_BIDDING
    }
  })
}

# Executed at init time
function init() {
  # Take off command for the Spiri drone model
  takeoff()

  # Show trajectory for debugging
  show_colored_trajectory(NUMBER_OF_ROBOTS)

  # Set first search position
  next_position.x = uniform(SEARCH_SPACE.minx, SEARCH_SPACE.maxx)
  next_position.y = uniform(SEARCH_SPACE.miny, SEARCH_SPACE.maxy)

  # Set initial state
  current_state = STATE_SEARCH
  found_gps = {.x = 0, .y = 0}
  
  init_stigmergies()
  init_listeners()
}

# Check if a target is in sight
function has_discovered_target()
{ 
  return detect_targets()
}

function safe_stigmergy_get(v_stigmergy, key, default) {
  var tmp = v_stigmergy.get(key)
  if (tmp != nil) {
    return tmp
  } else {
    return default
  }
}

function check_new_target() {
  var tmp = target_stigmergy.get("found_target_info")
  if (tmp != nil) {
    found_target_info = tmp
    if(found_target_info.found_by != -1 and found_target_info.found_by != id and current_state == STATE_SEARCH) {
      debug.print("Found by = ", found_target_info.found_by)
      current_state = STATE_NETWORKER
    }
  }
}

function search_state() {
  debug.print("Searching")
  # Check if need for networker
    # return
  # Look if a target is discovered
  if ( has_discovered_target() != 0 ) { 
    update_belief(1)
    found_gps.x = gps_position.x
    found_gps.y = gps_position.y
    # goto(MEETING_POINT.x, MEETING_POINT.y)
    current_state = STATE_FOUND
    current_search_step = 0      
  } 
  # If the max number of search step is reached go back to meeting point
  else if ( current_search_step >= NUMBER_OF_SEARCH_STEP ){ 
    goto(MEETING_POINT.x, MEETING_POINT.y)
    current_state = STATE_MEETING
    current_search_step = 0
    update_belief(0)
  }
  # Else continue searching
  else { 
    update_belief(0)
    if ( has_reached(next_position.x, next_position.y, DELTA_REACHED_POS) != 0 )
    {
      if (SEARCH_TYPE == 1) {
        random_belief_search()
      } else {
        random_search()
      }
      current_search_step = current_search_step + 1
    } else {
      goto(next_position.x, next_position.y)
    }
  }
}

function found_state() {
  debug.print("Found the target")
  # If the target is known to him:
    # GO back searching
  # Else
    # Go to rally point 
    # If reached 
      # If root:
        # Broadcast found target
      # else:
        # state =  ROOT_STATE
  if ( has_reached(MEETING_POINT.x, MEETING_POINT.y, DELTA_REACHED_POS) != 0 and found_target_info.found_by != id) {
    found_target_info = target_stigmergy.get("found_target_info")
    if (found_target_info != nil) {
      if (found_target_info.found_by == -1) { # We should only have one robot that broadcasts the found target
        log_metrics(nb_step, STATE_FOUND)
        found_target_info.found_by = id
        found_target_info.x = found_gps.x
        found_target_info.y = found_gps.y
        target_stigmergy.put("found_target_info", found_target_info)
      } else {
        current_state = STATE_NETWORKER
      }
    } else {
      found_target_info = { .found_by = -1, .x = 0.0, .y = 0.0 }
    }
  }
}

function root_state() {
  # Listen to broadcast for new_target
  neighbors.listen("new_target", function(vid, value, rid) {
    # get position of new target
    var new_candidate = value
    # if the new target was not already found
      # Add it to targets stack
  })

  # Listen to networker bid
  neighbors.listen("bid_value", function(vid, value, rid) {
    # get bid value
    if (current_best.value < value) {
      current_best.value = value
      current_best.best_id = rid
    }
  })
  # Create stack points for Networkers
  # If unassigned position in stack
    # Broadcast networker_needed with position
  # Broadcast winner after a 10 steps
}

function meeting_state() {
  debug.print("Periodic meeting")
  if ( has_reached(MEETING_POINT.x, MEETING_POINT.y, DELTA_REACHED_POS) == 0 ) {
    # Look for targets when comming back to meeting point
    if ( has_discovered_target() != 0 ) { 
      update_belief(1)
      found_gps.x = gps_position.x
      found_gps.y = gps_position.y
      # goto(MEETING_POINT.x, MEETING_POINT.y)
      current_state = STATE_FOUND
      current_search_step = 0      
    } else {
      update_belief(0)
    }
  }
  # When we get to the meeting point go back to searching when no networkers are needed
  else {
    found_target_info = { .found_by = -1, .x = 0.0, .y = 0.0 }
    next_position.x = uniform(SEARCH_SPACE.minx, SEARCH_SPACE.maxx)
    next_position.y = uniform(SEARCH_SPACE.miny, SEARCH_SPACE.maxy)
    goto(next_position.x, next_position.y)
    current_state = STATE_SEARCH
  }
}

function networker_bidding_state() {
  # Listen to winner 
  neighbors.listen("bid_winner", function(vid, winner_id, rid) {
    if (winner_id == id) {
      current_state = STATE_NETWORKER
    } else {
      current_state = STATE_SEARCH
    }
    # TODO: Check if it actually ignore or if it should be done somewhere else
    neighbors.ignore("bid_winner")
  })
  # Calculate distance from the position
  # Broadcast your bid
}

function networker_state() {
  # Goto(position)
  relay_id = id
  if (relay_id < found_target_info.found_by){
    relay_id = relay_id + 1
  }
  relay_ratio = float(relay_id) / float(NUMBER_OF_ROBOTS-1)
  relay_x = (found_target_info.x - MEETING_POINT.x ) * relay_ratio + MEETING_POINT.x
  relay_y = (found_target_info.y - MEETING_POINT.y ) * relay_ratio + MEETING_POINT.y
  next_position.x = relay_x
  next_position.y = relay_y
  goto(next_position.x, next_position.y)
  if ( has_reached(relay_x, relay_y, DELTA_REACHED_POS) != 0 and waiting_log != 0) {
    log_metrics(nb_step, STATE_NETWORKER)
    waiting_log = 0
  }
  if (math.abs(relay_ratio - 1) < 0.01)
  {
    debug.print("Follow target")
  }
  else
  {
    debug.print("Communication relay")
  }
}

# Executed every time step
function step() {
  update_gps_position()
  nb_step = nb_step + 1
  
  check_new_target()
  
  if (current_state == STATE_SEARCH){ 
    search_state()
  }
  else if ( current_state == STATE_FOUND ){ 
    found_state()
  }
  else if ( current_state == STATE_MEETING ){ 
    meeting_state()
  }
  else if ( current_state == STATE_NETWORKER )
  {
    networker_state()
  }
}
 
# Execute at exit
function destroy() {
}
