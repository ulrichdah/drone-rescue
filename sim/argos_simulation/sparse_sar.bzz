include "buzz_includes/buzz_utils/vec2.bzz"
include "config/search_example/parameters.bzz"
include "buzz_includes/search_example/utils.bzz"
include "buzz_includes/search_example/belief_search.bzz"
include "buzz_includes/debug.bzz"

var found_gps
var nb_step = 0
var waiting_log = 1

var current_bid_position = nil
var current_target = nil
var networkers_positions = nil
var graph = {}
var count_broadcast = 0
var cur_bid_id = 0
var current_best_bid = {.value = 0.0, .rid = -1}


function init_stigmergies() {
  target_stigmergy = stigmergy.create(1)
  root_id_stigmergy = stigmergy.create(2)
  if ( id == 0 ) {
    target_stigmergy.put("found_targets", found_targets)
    root_id_stigmergy.put("root_id", -1)
  }
  target_stigmergy.onconflict(function(k, l, r){
    return l
  })
  target_stigmergy.onconflictlost(function(k, l){})

  map_stigmergy = stigmergy.create(3)
  map_stigmergy.onconflict(function(k, l, r){
    return l
  })
  map_stigmergy.onconflictlost(function(k, l){})
}

function init_listeners() {
  neighbors.listen("networkers_need", function(vid, value, rid) {
    if (current_state == STATE_SEARCH or current_state == STATE_MEETING) {
      # get position for the bid
      current_bid_position = value.position
      cur_bid_id = value.id_bid
      log("POSTION FOR BID", current_bid_position)
      current_state = STATE_NETWORKER_BIDDING
    }
  })
}

# Executed at init time
function init() {
  # Take off command for the Spiri drone model
  takeoff()

  # Show trajectory for debugging
  show_colored_trajectory(NUMBER_OF_ROBOTS)

  # Set first search position
  next_position.x = uniform(SEARCH_SPACE.minx, SEARCH_SPACE.maxx)
  next_position.y = uniform(SEARCH_SPACE.miny, SEARCH_SPACE.maxy)

  # Set initial state
  current_state = STATE_SEARCH
  found_gps = {.x = 0, .y = 0}
  
  init_stigmergies()
  init_listeners()
}

# Check if a target is in sight
function has_discovered_target()
{ 
  return detect_targets()
}

# Returns difference between two vec2
function distance_v2(v1, v2) {
  return math.sqrt( ((v1.x - v2.x)*(v1.x - v2.x)) + ((v1.y - v2.y)*(v1.y - v2.y)) )    
}

# Check if given target position was already found
function is_new_target(target_position) {
  for (i = 0, i < size(found_targets), i = i + 1) {
    var existing_target_pos = found_targets[i].position
    var difference = distance_v2(existing_target_pos, target_position) 
    if (difference <= DELTA_REACHED_POS) {
      return 0
    }
  }
  return 1
}

# Check if a target was already processed (at least one existing relay)
function get_nearest_vertex(target_position) {
  var nearest_vertex = MEETING_POINT
  var nearest_distance = distance_v2(MEETING_POINT, target_position)
  for (i = 0, i < size(graph), i = i + 1) {
    if (distance_v2(graph[i], target_position) < nearest_distance) {
      nearest_vertex = graph[i]
      nearest_distance = distance_v2(graph[i], target_position)
    }
  }
  return nearest_vertex
}

# Returns a list of networkers positions for a given target
function get_networkers_positions(target_postion) {
  var start = get_nearest_vertex(target_position)
  var distance = math.vec2.length(math.vec2.sub(target_position, start))
  var unit_direction = math.vec2.norm(math.vec2.sub(target_position, start))
  var nb_networkers = int(distance / COMMUNICATION_RANGE)
  if (distance % COMMUNICATION_RANGE != 0) {
    nb_networkers = nb_networkers + 1
  }

  var positions = {}
  for (i = 0, i < nb_networkers - 1, i = i + 1) {
    var new_pos = {.x = unit_direction.x * COMMUNICATION_RANGE * i, .y = unit_direction.y * COMMUNICATION_RANGE * i}
    positions[i] = new_pos
  }
  positions[nb_networkers - 1] = target_position
  return positions
}

# Returns a bid value based on the distance from the given position
function get_bid(position) {
  var distance = distance_v2(position, gps_position)
  return 1 / distance
}

function safe_stigmergy_get(v_stigmergy, key, default) {
  var tmp = v_stigmergy.get(key)
  if (tmp != nil) {
    return tmp
  } else {
    return default
  }
}

function search_state() {
  debug.print("Searching")
  # Look if a target is discovered
  if ( has_discovered_target() != 0 ) { 
    update_belief(1)
    found_gps.x = gps_position.x
    found_gps.y = gps_position.y
    current_state = STATE_FOUND
    current_search_step = 0      
  } 
  # If the max number of search step is reached go back to meeting point
  else if ( current_search_step >= NUMBER_OF_SEARCH_STEP ){ 
    goto(MEETING_POINT.x, MEETING_POINT.y)
    current_state = STATE_MEETING
    current_search_step = 0
    update_belief(0)
  }
  # Else continue searching
  else { 
    update_belief(0)
    if ( has_reached(next_position.x, next_position.y, DELTA_REACHED_POS) != 0 )
    {
      if (SEARCH_TYPE == 1) {
        random_belief_search()
      } else {
        random_search()
      }
      current_search_step = current_search_step + 1
    } else {
      goto(next_position.x, next_position.y)
    }
  }
}

function found_state() {
  debug.print("Found the target")

  # Wait for ack from root if exists before leaving this state
  neighbors.listen("ack_new_target", function(vid, value, rid) {
    if (value == id) {
      current_state = STATE_SEARCH
    }
  })

  if (is_new_target(found_gps) != 0) {
    var root_id = safe_stigmergy_get(root_id_stigmergy, "root_id", -1)
    # Go to meeting zone if not there already
    if ( has_reached(MEETING_POINT.x, MEETING_POINT.y, DELTA_REACHED_POS) == 0) {
      goto(MEETING_POINT.x, MEETING_POINT.y)
      return
    }
    # We reached meeting zone
    if (root_id == -1) { # If no root exists, this drone is the root
      current_state =  STATE_ROOT
      root_id_stigmergy.put("root_id", id)
      found_targets[size(found_targets)] = {.processed = 0, .position = found_gps}
      target_stigmergy.put("found_targets", found_targets)
      return
    }
    neighbors.broadcast("new_target", found_gps)
  } else {
    current_state = STATE_SEARCH
  }
}

function root_state() {
  debug.print("ROOT")

  neighbors.ignore("networkers_need")
  # Listen to broadcast for new_target
  neighbors.listen("new_target", function(vid, new_target_position, rid) {
    neighbors.broadcast("ack_new_target", rid)
    var new_candidate = new_target_position
    if(is_new_target(new_candidate)) {
      # Add it to targets stack and update stigmergy
      found_targets[size(found_targets)] = {.processed = 0, .position = new_candidate}
      target_stigmergy.put("found_targets", found_targets)
    }
  })

  # Listen to networker bid
  neighbors.listen("bid_value", function(vid, info_bid, rid) {
    # get bid value
    if (current_best_bid.value < info_bid.value and info_bid.id_bid == cur_bid_id) {
      current_best_bid.value = info_bid.value
      current_best_bid.rid = rid
    }
  })

  var root_id = safe_stigmergy_get(root_id_stigmergy, "root_id", -1)
  if (root_id != id) {
    current_state =  STATE_SEARCH
    neighbors.broadcast("new_target", found_gps)
    neighbors.ignore("new_target")
    neighbors.ignore("bid_value")
    init_listeners()
    return
  }

  # Process next target
  if (current_target == nil) {
    var i = 0
    var continue = 1
    while(i < size(found_targets) and continue == 1) {
      if (found_targets[i].processed == 0) {
        current_target = found_targets[i].position
        found_targets[i].processed = 1
        continue = 0
      }
      i = i + 1
    }
  }

  # Create stack points for Networkers
  if (current_target != nil) {
    if (networkers_positions == nil) {
      networkers_positions = get_networkers_positions(current_target)
    }

    # If unassigned position in stack
    if (current_bid_position == nil) {
      var i = 0
      var continue = 1
      while(i < size(networkers_positions) and continue == 1) {
        if (networkers_positions[i] != nil) {
          current_bid_position = networkers_positions[i]
          current_best_bid = {.value = 0.0, .rid = -1}
          networkers_positions[i] = nil
          continue = 0
        }
        i = i + 1
      }
      # No more positions for this target
      if (continue == 1) {
        current_target = nil
      }
    }
    if (current_bid_position == nil) {
      return
    }
    # Broadcast networker_needed with position
    if (count_broadcast < 10) {
      neighbors.broadcast("networkers_need", {.id_bid = cur_bid_id, .position = current_bid_position})
      count_broadcast = count_broadcast + 1
    } else {
      # Broadcast winner after a 10 steps
      neighbors.broadcast("bid_winner", current_best_bid.rid)
      current_bid_position = nil
      count_broadcast = 0
    }
  }
}

function meeting_state() {
  debug.print("Periodic meeting")
  # Update local list of targets
  found_targets = safe_stigmergy_get(target_stigmergy, "found_targets", found_targets)
  if ( has_reached(MEETING_POINT.x, MEETING_POINT.y, DELTA_REACHED_POS) == 0 ) {
    # Look for targets when comming back to meeting point
    if ( has_discovered_target() != 0 ) { 
      update_belief(1)
      found_gps.x = gps_position.x
      found_gps.y = gps_position.y
      current_state = STATE_FOUND
      current_search_step = 0      
    } else {
      update_belief(0)
    }
  }
  # When we get to the meeting point go back to searching when no networkers are needed
  else {
    found_target_info = { .found_by = -1, .x = 0.0, .y = 0.0 }
    next_position.x = uniform(SEARCH_SPACE.minx, SEARCH_SPACE.maxx)
    next_position.y = uniform(SEARCH_SPACE.miny, SEARCH_SPACE.maxy)
    goto(next_position.x, next_position.y)
    current_state = STATE_SEARCH
  }
}

function networker_bidding_state() {
  debug.print("Networker bidding")
  # Listen to winner 
  neighbors.listen("bid_winner", function(vid, winner_id, rid) {
    if (winner_id == id) {
      current_state = STATE_NETWORKER
    } else {
      current_state = STATE_SEARCH
      current_bid_position = nil
    }
    # TODO: Check if it actually ignore or if it should be done somewhere else
    neighbors.ignore("bid_winner")
  })
  
  var r_bid = get_bid(current_bid_position)
  neighbors.broadcast("bid_value", {.id_bid = cur_bid_id, .value = r_bid})
}

function networker_state() {
  debug.print("Networker")
  goto(current_bid_position.x, current_bid_position.y)
}

# Executed every time step
function step() {
  update_gps_position()
  nb_step = nb_step + 1
  
  if (current_state == STATE_SEARCH) { 
    search_state()
  } else if (current_state == STATE_FOUND) { 
    found_state()
  } else if (current_state == STATE_ROOT) {
    root_state()
  } else if (current_state == STATE_MEETING) { 
    meeting_state()
  } else if (current_state == STATE_NETWORKER_BIDDING) {
    networker_bidding_state()
  } else if (current_state == STATE_NETWORKER) {
    networker_state()
  }
}
 
# Execute at exit
function destroy() {
}
